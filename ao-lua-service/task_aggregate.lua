-- <autogenerated>
--   This file was generated by dddappp code generator.
--   Any changes made to this file manually will be lost next time the file is regenerated.
-- </autogenerated>

local entity_coll = require("entity_coll")
local json = require("json")
local task_id = require("task_id")
local task_create_task_logic = require("task_create_task_logic")
local task_update_task_logic = require("task_update_task_logic")
local task_start_task_logic = require("task_start_task_logic")
local task_complete_task_logic = require("task_complete_task_logic")
local task_cancel_task_logic = require("task_cancel_task_logic")
local task_create_logic = require("task_create_logic")
local task_update_logic = require("task_update_logic")

local task_aggregate = {}

local ERRORS = {
    NIL_ENTITY_ID_SEQUENCE = "NIL_ENTITY_ID_SEQUENCE",
    ENTITY_ID_MISMATCH = "ENTITY_ID_MISMATCH",
    CONCURRENCY_CONFLICT = "CONCURRENCY_CONFLICT",
    VERSION_MISMATCH = "VERSION_MISMATCH",
}

task_aggregate.ERRORS = ERRORS

local task_table
local task_id_sequence

local function current_task_id()
    if (task_id_sequence == nil) then
        error(ERRORS.NIL_ENTITY_ID_SEQUENCE)
    end
    return task_id_sequence[1]
end

local function next_task_id()
    if (task_id_sequence == nil) then
        error(ERRORS.NIL_ENTITY_ID_SEQUENCE)
    end
    task_id_sequence[1] = task_id_sequence[1] + 1
    return task_id_sequence[1]
end


function task_aggregate.init(table, seq)
    task_table = table
    task_id_sequence = seq
end

function task_aggregate.create_task(cmd, msg, env)
    local _task_id = cmd.task_id
    local _task_id_key = json.encode(task_id.to_key_array(_task_id))
    local _state = entity_coll.get_copy_or_else_nil(task_table, _task_id_key)
    if (_state and _state.version ~= cmd.version) then
        error(ERRORS.CONCURRENCY_CONFLICT)
    end
    if (_state) then
        _state.task_id = _task_id
    end
    local version = _state and _state.version or nil
    local _event = task_create_task_logic.verify(_state, _task_id, cmd.title, cmd.description, cmd.priority, cmd.assignee, cmd.due_date, cmd.tags, cmd, msg, env)
    if (_event.task_id ~= _task_id) then
        error(ERRORS.ENTITY_ID_MISMATCH)
    end
    if (version and (_event.version ~= version)) then
        error(ERRORS.VERSION_MISMATCH)
    end
    local _new_state = task_create_task_logic.mutate(_state, _event, msg, env)
    _new_state.task_id = _task_id
    _new_state.version = version and (version + 1) or 0
    local commit = function()
        entity_coll.add_or_update(task_table, _task_id_key, _new_state)
    end

    return _event, commit
end

function task_aggregate.update_task(cmd, msg, env)
    local _task_id_key = json.encode(task_id.to_key_array(cmd.task_id))
    local _state = entity_coll.get_copy(task_table, _task_id_key)
    if (_state.version ~= cmd.version) then
        error(ERRORS.CONCURRENCY_CONFLICT)
    end
    local _task_id = _state.task_id
    local version = _state.version
    local _event = task_update_task_logic.verify(_state, cmd.title, cmd.description, cmd.priority, cmd.assignee, cmd.due_date, cmd.tags, cmd, msg, env)
    if (_event.task_id ~= _task_id) then
        error(ERRORS.ENTITY_ID_MISMATCH)
    end
    if (_event.version ~= version) then
        error(ERRORS.VERSION_MISMATCH)
    end
    local _new_state = task_update_task_logic.mutate(_state, _event, msg, env)
    _new_state.task_id = _task_id
    _new_state.version = (version and version or 0) + 1
    local commit = function()
        entity_coll.update(task_table, _task_id_key, _new_state)
    end

    return _event, commit
end

function task_aggregate.start_task(cmd, msg, env)
    local _task_id_key = json.encode(task_id.to_key_array(cmd.task_id))
    local _state = entity_coll.get_copy(task_table, _task_id_key)
    if (_state.version ~= cmd.version) then
        error(ERRORS.CONCURRENCY_CONFLICT)
    end
    local _task_id = _state.task_id
    local version = _state.version
    local _event = task_start_task_logic.verify(_state, cmd, msg, env)
    if (_event.task_id ~= _task_id) then
        error(ERRORS.ENTITY_ID_MISMATCH)
    end
    if (_event.version ~= version) then
        error(ERRORS.VERSION_MISMATCH)
    end
    local _new_state = task_start_task_logic.mutate(_state, _event, msg, env)
    _new_state.task_id = _task_id
    _new_state.version = (version and version or 0) + 1
    local commit = function()
        entity_coll.update(task_table, _task_id_key, _new_state)
    end

    return _event, commit
end

function task_aggregate.complete_task(cmd, msg, env)
    local _task_id_key = json.encode(task_id.to_key_array(cmd.task_id))
    local _state = entity_coll.get_copy(task_table, _task_id_key)
    if (_state.version ~= cmd.version) then
        error(ERRORS.CONCURRENCY_CONFLICT)
    end
    local _task_id = _state.task_id
    local version = _state.version
    local _event = task_complete_task_logic.verify(_state, cmd, msg, env)
    if (_event.task_id ~= _task_id) then
        error(ERRORS.ENTITY_ID_MISMATCH)
    end
    if (_event.version ~= version) then
        error(ERRORS.VERSION_MISMATCH)
    end
    local _new_state = task_complete_task_logic.mutate(_state, _event, msg, env)
    _new_state.task_id = _task_id
    _new_state.version = (version and version or 0) + 1
    local commit = function()
        entity_coll.update(task_table, _task_id_key, _new_state)
    end

    return _event, commit
end

function task_aggregate.cancel_task(cmd, msg, env)
    local _task_id_key = json.encode(task_id.to_key_array(cmd.task_id))
    local _state = entity_coll.get_copy(task_table, _task_id_key)
    if (_state.version ~= cmd.version) then
        error(ERRORS.CONCURRENCY_CONFLICT)
    end
    local _task_id = _state.task_id
    local version = _state.version
    local _event = task_cancel_task_logic.verify(_state, cmd, msg, env)
    if (_event.task_id ~= _task_id) then
        error(ERRORS.ENTITY_ID_MISMATCH)
    end
    if (_event.version ~= version) then
        error(ERRORS.VERSION_MISMATCH)
    end
    local _new_state = task_cancel_task_logic.mutate(_state, _event, msg, env)
    _new_state.task_id = _task_id
    _new_state.version = (version and version or 0) + 1
    local commit = function()
        entity_coll.update(task_table, _task_id_key, _new_state)
    end

    return _event, commit
end

function task_aggregate.create(cmd, msg, env)
    local _task_id_num = next_task_id()
    local _task_id = task_id.new(tostring(_task_id_num))
    local _task_id_key = json.encode(task_id.to_key_array(_task_id))
    local _event = task_create_logic.verify(_task_id, cmd.title, cmd.description, cmd.priority, cmd.assignee, cmd.due_date, cmd.status, cmd.tags, cmd, msg, env)
    if (_event.task_id.id ~= tostring(current_task_id())
        or _event.task_id.id ~= tostring(_task_id_num)
    ) then
        error(ERRORS.ENTITY_ID_MISMATCH)
    end
    local _state = task_create_logic.new(_event, msg, env)
    _state.task_id = _event.task_id
    local commit = function()
        entity_coll.add(task_table, _task_id_key, _state)
    end

    return _event, commit
end

function task_aggregate.update(cmd, msg, env)
    local _task_id_key = json.encode(task_id.to_key_array(cmd.task_id))
    local _state = entity_coll.get_copy(task_table, _task_id_key)
    if (_state.version ~= cmd.version) then
        error(ERRORS.CONCURRENCY_CONFLICT)
    end
    local _task_id = _state.task_id
    local version = _state.version
    local _event = task_update_logic.verify(_state, cmd.title, cmd.description, cmd.priority, cmd.assignee, cmd.due_date, cmd.status, cmd.tags, cmd, msg, env)
    if (_event.task_id ~= _task_id) then
        error(ERRORS.ENTITY_ID_MISMATCH)
    end
    if (_event.version ~= version) then
        error(ERRORS.VERSION_MISMATCH)
    end
    local _new_state = task_update_logic.mutate(_state, _event, msg, env)
    _new_state.task_id = _task_id
    _new_state.version = (version and version or 0) + 1
    local commit = function()
        entity_coll.update(task_table, _task_id_key, _new_state)
    end

    return _event, commit
end

return task_aggregate
